Hello folks, so a bit of a background about me:
I am Krishna Shandilya, a Scond yar from biomdical enginring, (You will see a lot of typos espcially relatd to th lttr e, caus my keyboard kinda bad :( sorry for th inconvininc):

log0016(So i kind oif get the gist of wht i have to do, i believe i am mainly expected to study about the GPS module, and figure out how this works, by myslf and thr's a rovr somwhre streaming the location data and i hav to subscribe to that somhow) mayb i will look it how th modul works for now and gt a bttr undrstanding of th task using gemini

log0024( SO i ralised that i forgot to fork th rpository whn th tst was goin on and i misundrstood and mad my own rpository and uploadd that link to th form, so i am gonna just push all th cod into the rpository whos link i alrady postd)

log0110( got stuck in a dependency hell, anyway, so yah as i thought th ublox thingy is consitntly streaming the data and they are in the Binary langauge which is there in the NAV_UBX thingy imma study sbout the UBX format, i went though thr code and i believe there's a problem with ublox_reader.cpp)

log1116(allright just remembered to update the Readme of the file, I largely utilised Gemini and Claude for this task as i knew very little about the Cpp language in general, and will try my best to explain the core problems with the code and how i debugged them), so there were three main tasks:
1. decode The GPS data
(go though the ublox pdf to figure out thr pattern, and make changes to two main functions decode and add '+ 4 ' in the syntax one above, I make an understand of this as how you get an exact decimal value out using a decoder in electronics, though there could be maximum 6 bits for ublox, the other two for redundant in our us case overhere right now or that's what my understanding is)
2. Path planning 
(which was done using the A star algorithm and I did that by first visualising the map after test 1 was cleared. and then constructed the algorithm but algorithm which was constructed inonitself was super inefficient: It would only move straightâ€”up, down, left, or rightâ€”and make sharp 90-degree turns. and mostly stayed on the sidewalks and spiraled into the location, I copied this explanation and pasted into Claude along with the algorithm and then the coordinates generated were really clean and concise)
3.Odometery: I had a vague idea of ehat odometer is, it is to generally localised a bot in an environment using the help of external sensors and encoders which i generally utilised to make digital twins in Matlab and Gazebo but I had never written a code for it myself, though I gave it a try but it didnt really work out ðŸ¥², the thing i had to do it was that the total turning angle was wrong  and cause of that I kept encountering error. i had to do two things which was to figure out the time it took and the total angle it turned, well I did it anyway (this i did it manually who hoo!) so I had to add the total angle it turned after every step and it had to be 720, asking me to take more turns, wierd condition but yeah. and since ma rover's total sum was coming upto be 270, I just had make the rover take a longer way areound ig.....)